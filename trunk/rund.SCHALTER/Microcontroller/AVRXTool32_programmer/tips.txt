■AVRライタ制御プログラム TIPS

  このファイルには AVRライタ製作を通して得られたノウハウや注意点など本文で
説明しきれなかった細かい部分を記しておきます。実際に制御プログラムを書かれ
たりライタを改良する際の手助けとなれば幸いです。



●タイミング生成

  ライタ制御のタイミングを得るために、ms単位ではシステムBIOSのディレイ機能
を μs単位では MPU速度依存の少ない I/Oリードを使用しています。



●デバイスの自動認識（パラレルモード）

  パラレルモードの場合、まず 20ピンデバイスとしてデバイスID読み込みを試みて、
失敗したら 8ピンデバイスとして再び ID認識を試みます。8ピンデバイスではさらに
標準手順(x1 clock)とtiny15手順(x16 clock)の2通りでトライします。
  これにより、プログラム方式の異なる 8ピンデバイスも含めて全てのデバイスで
自動認識が可能となっています。



●デバイスの自動認識（ISPモード）

  1200とそれ以外のデバイスでは、最初のコマンド同期シーケンスの手順が異なり
ます。
  そこで、まず 1200方式（RESETパルス）で同期シーケンスを実行して次にエコー
バック方式を試みるようにしています。有効なデバイスIDが読み出せるまで「同期
→ID読み出し」を３回までリトライしますが、最初の２回は1200方式、３回目はエ
コーバックで同期シーケンスを実行します。これにより、ISPモードにおいても全て
のデバイスで自動認識を実現しています。



●0xFFスキップ

  書き込み時間を短縮するため、書き込む必要の無いバイト(またはページ)、たとえ
ばロードされなかった領域やプログラムメモリで値が 0xFF、へのプログラム動作は
スキップしています。



●書き込み完了待ち（ISPモード）

  ISPモードでは、デバイス内でのバイト書き込みの完了を待つのにポーリングを
使用しています。このため、書き込み時間は個々のデバイスの能力と電源電圧に
依存することになります。
  しかし、1200はデータシートに記されているにも関わらずポーリングがうまく機
能しないようなので、これについては 12msのタイマーで次のバイトに移るようにし
ています（5Vでは 4msで OKだが、3Vまでカバーするにはこの程度必要）。
  また、ページモード書き込みのデバイスでは、ページ書き込みの終了待ちをタイ
マーとしています。



●キャリブレーションバイト(CAL値)について

  オシレータ内蔵デバイスの多くは、OSCCALレジスタにCAL値を書き込んで発振周
波数の製造上のバラツキを補正をするようになっています。この値はプログラマで
読み出すことができます。avrpp/avrspの場合、ヒューズ読み出しでそのデバイス
のCAL値が確認できます。CAL値は、1または 4個の10進数で表示され、4個ある場合
は、左から順に 1MHz用、2MHz用、4MHz用、8MHz用です。
  特にOSCCALレジスタの初期値が0になる古いデバイスは、内蔵オシレータを使う場
合、必ず初期化動作が必要になります。デバイス毎に固有なCAL値は、何らかの手段
でプログラム中に埋め込む必要があります。多数のデバイスに書き込む場合は、
ソースファイルにCAL値を直接コーディングすることが難しいので、プログラマ側
での対応も必要になります。
  プログラム書き込み時には -c スイッチを指定すると、CAL値をフラッシュメモリ
の最後バイトにセットします。4個ある場合は、最終バイトから順に1MHz用...8MHz用
で配置されます。プログラムは初期化時にそれを読み出して設定してやればOKです。

example:
    c = pgm_read_byte(FLASHEND - n); // written by -c switch
    if(c != 0xFF) OSCCAL = c;



●ISP動作での通信速度

  -d スイッチは、ISPモードでのデバイスとの通信速度を変更します。ISP動作で
可能な通信速度はデバイスの動作クロックに依存するので、通信速度調整のため
タイミングディレイを挿入しています。低速クロック時にデバイスを認識できな
いときは、速度を調整してみてください。



●パラレルライタでの１回目の書き込み

  パラレルライタでは、VccとVppの制御にパラレルポートのコントロール信号を使っ
ています。これらの信号は、アクティブ "L"なので、通常は"H"レベルです。このた
め、ライタを使用する前は Vccと Vppが ONの状態になっています。この状態でソケッ
トにデバイスをセットするとデバイスを壊す恐れがあるので、少なくとも初回は制御
プログラムのデバイスセット要求が出てからソケットにセットする必要があります。



●プログラム電圧発生回路（パラレルライタ）

  パラレルモードと8ピンデバイスの高電圧シリアルモードでは、+12Vのプログラ
ム電圧が必要です。このため、パラレルライタでは、ボード上に DC-DCコンバータ
を載せています。AVRチップ自体は+12Vをほとんど消費しないので、+12Vの電流は
10mAもあれば OKです。他の DC-DCコンバータで置きかえる場合はその程度の容量を
目安に設計してください。12V以上の電源が用意できるなら、それを利用するのが
最も簡単でしょう。



●パラレルライタの変換ソケット

  パラレルライタでは、20ピンデバイスを基本にして、それ以外は変換ソケット
で対応するようにしています。でも、最初からそれぞれの変換ソケットを製作す
るくらいなら、それぞれのデバイス用ソケットを全てボード上に実装してしまった
ほうが楽かも知れません。当然ですが、同時にセットできるデバイスは1個だけで
す。



●RSTDISBLヒューズ

  いくつかのデバイスではRESETピンをポートとして使う設定がありますが、その
状態ではISPモードが動作しなくなります。ISPモードではRSTDISBLヒューズを誤っ
てプログラムしないよう注意が必要です。



●JTAGENヒューズ

  最近発表されたデバイスはJTAG機能を持っているものが増えています。デフォルト
では JTAGが有効になっていて、重複するピンが I/Oポートとして使えません。
これを普通に使えるようにするには、JTAGENヒューズをアンプログラム（"1"）する
か、実行時に MCU制御レジスタの JTDビットを立てる必要があります。



●avrspのアダプタ認識

  avrspは複数のプログラミングアダプタに対応するため、アダプタのタイプを自動
認識しています。次の順にパラレルポートの接続をチェックして、最初にマッチした
組み合わせでアダプタタイプを決定します。

1. D5-ACK        Altera ByteBlasterMV
2. D7-PE         AVRX
3. D6-BUSY-PE    Xilinx JTAG
4. D6-PE         Lattice ISP
5. D0-PE         STK200 dongle
